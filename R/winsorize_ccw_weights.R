#' Winsorize clone censor weights (CCW) on the long data.frame
#' 
#' Remove extreme weights from the long data.frame generated by [generate_ccw()] to avoid influential observations. 
#' Uses `stats::quantile()`.
#' 
#' @param df A data.frame with one row per clone per observation period that contains weights for each patient-period as returned by [generate_ccw()]
#' @param quantiles A vector of two values between 0 and 1 that define the lower and upper quantiles to use for winsorization. Default is c(0.01, 0.99).
#' @param per_clone Boolean indicating whether to winsorize the weights according to quantiles per clone (TRUE) or across all clones (FALSE). Default is FALSE. Weights
#' get winsorized for all patient-periods in both cases.
#' @return The same data.frame with weights winsorized.
#' 
#' @export
#' @importFrom stats quantile
#' @examples 
#' 
#' # Load the toy dataset
#' data(toy_df)
#' 
#' # Create clones
#' clones <- create_clones(toy_df, 
#'                         id = "id", 
#'                         event = "death", 
#'                         time_to_event = "fup_obs", 
#'                         exposure = "surgery", 
#'                         time_to_exposure = "timetosurgery", 
#'                         ced_window = 365.25/2)
#' 
#' clones_long <- cast_clones_to_long(clones)
#' clones_long_w <- generate_ccw(clones_long, predvars = c("age"))
#' clones_long_w_wins <- winsorize_ccw_weights(clones_long_w)
winsorize_ccw_weights <- function(df, quantiles = c(0.01, 0.99), per_clone = FALSE) {

   # Check inputs
   checkmate::assert_class(df, "ccw_clones_long_weights")
   weight_name <- attributes(df)$weight_name
   if (!all(c("outcome", "fup_outcome", "censor", "fup_censor", "clone", "t_start", "t_stop", "time_id", "t_event", weight_name) %in% names(df))) {
      stop("The input data.frame is missing at least one of the required columns: outcome, fup_outcome, censor, fup_censor, clone, t_start, t_stop, time_id, t_event, ", weight_name, ". Did you remove this?")
   }

   # Check quantiles
   if (length(quantiles) != 2) {
      stop("quantiles must be a vector of two values between 0 and 1.")
   }
   if (any(quantiles < 0) | any(quantiles > 1)) {
      stop("quantiles must be between 0 and 1.")
   }
   if (quantiles[1] >= quantiles[2]) {
      stop("The first quantile must be smaller than the second quantile.")
   }

   # Group
   if (per_clone) {
      grouping_factor <- interaction(df$time_id, df$clone)
   } else {
      grouping_factor <- df$time_id
   }

   # Get quantiles
   quantile_values <- tapply(df[[weight_name]], grouping_factor, FUN = quantile, probs = quantiles)

   # Winsorize
   unique_groups <- unique(grouping_factor)
   for (group in unique_groups) {
      lower_bound <- quantile_values[[as.character(group)]][1]
      upper_bound <- quantile_values[[as.character(group)]][2]
      df[grouping_factor == group, weight_name] <- pmin(pmax(df[grouping_factor == group, weight_name], lower_bound), upper_bound)
   }

   # Return
   return(df)

}